This was a problem where I just assumed the numbers would be too big to work with and actually they kinda weren't. I thought I had to do some clever maths to calculate the number of invalid IDs. And to a degree that's true. I certainly wanted to avoid checking all the numbers for each range.

Rather, I just wanted to build up the invalid IDs that fit between the ranges and add them up. The main gotcha was making sure I check for the edges to see if repeated digit sequeces fall outside the range. And since I just had to check if the digit sequeces are repeated twice, I was able to ignore the odd-length digits (I assumed I'd have to stop doing that for part 2)

For part two, as I assumed, I had to check repeated sequeces for more than just twice. I didn't expect just n number of times. But I was able to limit it because the max number of times is the length of the range bounds. I processed the ranges first to divide into ranges of equal digit length, to make life easier. Then I checked different lengths of repeated sequences (only had to check the ones possible, i.e the factors of the total digit count of the numbers). The edges gotcha was still there but slightly more complicated. But after I handled that, I was able to get all the invalid IDs. I used a set to avoid double-counting any and then took the sum by the end.
